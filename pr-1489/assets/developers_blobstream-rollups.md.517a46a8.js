import{_ as e,o as t,c as a,Q as o}from"./chunks/framework.611656c0.js";const f=JSON.parse('{"title":"","description":"Learn how to build rollups that use Blobstream","frontmatter":{"description":"Learn how to build rollups that use Blobstream","head":[["meta",{"name":"og:title","content":" | Celestia Docs"},{"name":"og:description","content":false}]]},"headers":[],"relativePath":"developers/blobstream-rollups.md","filePath":"developers/blobstream-rollups.md","lastUpdated":1711130740000}'),s={name:"developers/blobstream-rollups.md"},i=o('<h2 id="optimistic-rollups" tabindex="-1">Optimistic rollups <a class="header-anchor" href="#optimistic-rollups" aria-label="Permalink to &quot;Optimistic rollups&quot;">​</a></h2><p>The easiest to build with Blobstream are optimistic rollups. An optimistic rollup is a rollup that commits optimistically to a set of blocks, and allows the other parties to verify that the blocks are valid, and if they&#39;re not, they can create fraud proofs to signal that.</p><p>Through the use of Blobstream, Celestia allows optimistic rollups to use Celestia as a DA layer, i.e. posting all the rollup data to Celestia, and only send commitments to the settlement contract. Then, users can use Blobstream as a source of truth to verify the rollup data and create fraud proofs in case of a misbehavior.</p><p>To build an optimistic rollup that uses Celestia as a DA layer, the following constructions can be inspired by.</p><h3 id="optimistic-rollups-that-uses-a-sequence-of-spans" tabindex="-1">Optimistic rollups that uses a sequence of spans <a class="header-anchor" href="#optimistic-rollups-that-uses-a-sequence-of-spans" aria-label="Permalink to &quot;Optimistic rollups that uses a sequence of spans&quot;">​</a></h3><p>One way to construct an optimistic rollup that uses Celestia as a DA layer is to post the rollup data in Celestia. Then in the rollup header, use the following information to reference a sequence of spans, aka a data pointer:</p><ul><li>Height: the height of the Celestia block containing the rollup data</li><li>Start share: which is the index of the first share containing the rollup data</li><li>Data length: which is the number of shares that the rollup data occupies</li></ul><p>Note: If the rollup data is submitted in multiple blocks, the above sequence of spans can be generalized to include multiple blocks. For simplicity, we will stick with the data only submitted to a single Celestia block.</p><p>Now that this information is saved in the rollup header/settlement contract, users/rollup full nodes will be able to query for the rollup data from Celestia and verify that it&#39;s valid. And if it&#39;s not, fraud proofs can be generated.</p><p>The fraud proofs in this setup are discussed in the <a href="https://github.com/celestiaorg/blobstream-contracts/blob/master/docs/inclusion-proofs.md" target="_blank" rel="noreferrer">inclusion proofs</a> documentation.</p><h3 id="optimistic-rollups-that-use-the-data-commitment" tabindex="-1">Optimistic rollups that use the data commitment <a class="header-anchor" href="#optimistic-rollups-that-use-the-data-commitment" aria-label="Permalink to &quot;Optimistic rollups that use the data commitment&quot;">​</a></h3><p>Another way to build a rollup is to replace the sequence of spans with a height and a share commitment. Then, users/rollup full nodes will be able to query that data, and in case of a dispute, they can create a fraud proof.</p><p>The difference between the above construction and this one is that the proofs used will be different: when using a sequence of spans, the inclusion proofs will be straight from the rollup data up to the <a href="https://github.com/celestiaorg/blobstream-contracts/blob/master/README.md#how-it-works" target="_blank" rel="noreferrer">data root tuple root</a>. However, in the case of the use of the height and the share commitment, an extra step would need to be done when posting the header to the settlement contract, which is proving that the provided commitment is part of the Celestia block (referenced by its height). Then, fraud proofs will need to prove the following:</p><ul><li>share inclusion to the share commitment</li><li>share commitment inclusion to the data root tuple root</li></ul><p>Once these are valid, the rollup contract can proceed to parse the share and verify the contested claim.</p><p>Note: <strong>Generating/verifying share commitment proofs is still not supported. Thus, the <a href="#optimistic-rollups-that-uses-a-sequence-of-spans">sequence of spans</a> approach is preferable at the moment.</strong></p><h2 id="zk-rollups" tabindex="-1">Zk-Rollups <a class="header-anchor" href="#zk-rollups" aria-label="Permalink to &quot;Zk-Rollups&quot;">​</a></h2><p>Zk-rollups, aka validity rollups, can also use Celestia as a DA and Blobstream to verify that the data was posted. However, the submission process is different from the above constructions, since there are no fraud proofs, and everything should be verified when submitting the headers.</p><p>So, when posting to the settlement contract, the rollup data in Celestia can be referenced either using a share commitment or a sequence of spans, and a height. However, as explained above, the share commitment proofs generation/verification is still not supported. Thus, we will focus on the case where we use a sequence of spans. Check the <a href="#optimistic-rollups-that-uses-a-sequence-of-spans">Optimistic rollups that uses a sequence of spans</a> for more information.</p><p>So, when submitting the headers to the rollup settlement contract, the settlement contract will need to verify the following:</p><ul><li>Zk-proof of the state transitions, as traditional zk-rollups do.</li><li>Zk-proof of the rollup data to the data root tuple root. The verification process of this should accept a commitment as input so that the contract makes sure it&#39;s the correct value that&#39;s being saved.</li><li>Verify that the sequence of spans is valid, i.e., is part of the Celestia block referenced by its height.</li></ul><p>Once these are valid, the settlement contract can be sure that the state transitions are valid, and the data was posted to Celestia.</p>',22),l=[i];function r(n,h,p,c,u,d){return t(),a("div",null,l)}const b=e(s,[["render",r]]);export{f as __pageData,b as default};
