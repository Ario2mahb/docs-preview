import{_ as e,o as t,c as o,Q as a}from"./chunks/framework.611656c0.js";const f=JSON.parse('{"title":"","description":"Learn how to build rollups that use Blobstream","frontmatter":{"description":"Learn how to build rollups that use Blobstream","head":[["meta",{"name":"og:title","content":" | Celestia Docs"},{"name":"og:description","content":false}]]},"headers":[],"relativePath":"developers/blobstream-rollups.md","filePath":"developers/blobstream-rollups.md","lastUpdated":1711551402000}'),s={name:"developers/blobstream-rollups.md"},i=a('<h2 id="optimistic-rollups" tabindex="-1">Optimistic rollups <a class="header-anchor" href="#optimistic-rollups" aria-label="Permalink to &quot;Optimistic rollups&quot;">​</a></h2><p>One type of rollups that can be built with Blobstream is optimistic rollups. An optimistic rollup is a rollup that commits optimistically to a set of blocks, and allows the other parties to verify that the blocks are valid, and if they&#39;re not, they can create fraud proofs to signal that.</p><p>Through the use of Blobstream, Celestia allows optimistic rollups to use Celestia as a DA layer, i.e., posting all the rollup data to Celestia, and only send commitments to the settlement contract. Then, users can use Blobstream as a source of truth to verify the rollup data and create fraud proofs in case of a misbehavior.</p><p>To build an optimistic rollup that uses Celestia as a DA layer, the following constructions can be inspired by.</p><h3 id="optimistic-rollups-that-uses-a-sequence-of-spans" tabindex="-1">Optimistic rollups that uses a sequence of spans <a class="header-anchor" href="#optimistic-rollups-that-uses-a-sequence-of-spans" aria-label="Permalink to &quot;Optimistic rollups that uses a sequence of spans&quot;">​</a></h3><p>One way to construct an optimistic rollup that uses Celestia as a DA layer is to post the rollup data in Celestia. Then in the rollup header, use the following information to reference a sequence of spans, aka a data pointer:</p><ul><li><code>Height</code>: the height of the Celestia block containing the rollup data</li><li><code>Start share</code>: the index of the first share containing the rollup data</li><li><code>Data length</code>: the number of shares that the rollup data occupies</li></ul><p>Note: If the rollup data is submitted in multiple blocks, the above sequence of spans can be generalized to include multiple blocks. For simplicity, we will stick with the data only submitted to a single Celestia block.</p><p>Now that this information is saved in the rollup header/settlement contract, and users/rollup full nodes will be able to query for the rollup data from Celestia and verify that it&#39;s valid. And if it&#39;s not, fraud proofs can be generated.</p><p>The proofs in this setup are discussed in the <a href="https://github.com/celestiaorg/blobstream-contracts/blob/master/docs/inclusion-proofs.md" target="_blank" rel="noreferrer">inclusion proofs</a> documentation.</p><h3 id="optimistic-rollups-that-use-share-commitments" tabindex="-1">Optimistic rollups that use share commitments <a class="header-anchor" href="#optimistic-rollups-that-use-share-commitments" aria-label="Permalink to &quot;Optimistic rollups that use share commitments&quot;">​</a></h3><p>Another way to build a rollup is to replace the sequence of spans with a <code>height</code> and a <code>share commitment</code>. Then, users/rollup full nodes will be able to query that data, and in case of a dispute, they can create a fraud proof.</p><p>The difference between the above construction and this one is that the proofs used will be different: when using a sequence of spans, the inclusion proofs will be straight from the rollup data up to the <a href="https://github.com/celestiaorg/blobstream-contracts/blob/master/README.md#how-it-works" target="_blank" rel="noreferrer">data root tuple root</a>. However, in the case of using the <code>height</code> and the <code>share commitment</code>, an extra step would need to be done when posting the header to the settlement contract. This step is proving that the provided commitment is part of the Celestia block (referenced by its height). Then, fraud proofs will need to prove the following:</p><ul><li>share inclusion to the share commitment: meaning creating two merkle proofs: <ul><li>share merkle proof up to the <a href="https://celestiaorg.github.io/celestia-app/specs/data_square_layout.html#blob-share-commitment-rules" target="_blank" rel="noreferrer">subtree root</a> corresponding to that share</li><li>subtree root merkle proof to the <a href="https://celestiaorg.github.io/celestia-app/specs/data_square_layout.html#blob-share-commitment-rules" target="_blank" rel="noreferrer">share commitment</a></li></ul></li><li>share commitment inclusion to the data root tuple root: meaning four merkle proofs: <ul><li>subtree roots merkle proofs to the share commitment: to make sure the subtree roots are valid</li><li>subtree roots merkle proofs up to the row roots: to prove that the subtree roots belong to a set of rows</li><li>row roots proofs to the data root</li><li>data root tuple proof to the data root tuple</li></ul></li></ul><p>Once these are valid, the rollup contract can proceed to parse the share and verify the contested claim.</p><p>Note: <strong>Generating/verifying share commitment proofs is still not supported. It still needs tooling to generate the proofs on the node side, and verifying them on the Solidity side which will be built in the upcoming months. Thus, the <a href="#optimistic-rollups-that-uses-a-sequence-of-spans">sequence of spans</a> approach is preferable at the moment. Also, the gas cost of verifying all the above proofs needs to be investigated.</strong></p><h4 id="protobuf-deserialization-in-solidity" tabindex="-1">Protobuf deserialization in Solidity <a class="header-anchor" href="#protobuf-deserialization-in-solidity" aria-label="Permalink to &quot;Protobuf deserialization in Solidity&quot;">​</a></h4><p>Another alternative when using the share commitment to reference the rollup data is to parse the PFB, i.e., the protobuf serialized PayForBlob transaction, inside the rollup settlement contract and verify that the parsed share commitment is the same. Then, proving the inclusion of the PFB to the data root tuple root. More details on this can be found in <a href="https://github.com/celestiaorg/celestia-app/blob/main/docs/architecture/adr-011-optimistic-blob-size-independent-inclusion-proofs-and-pfb-fraud-proofs.md" target="_blank" rel="noreferrer">ADR-011</a>.</p><p>The issue with this approach is needing a library to parse the protobuf in solidity and the gas cost that comes with it. Otherwise, proving the PFB to the data root tuple root is cheaper than proving the blob, because it needs only proving two shares.</p><h2 id="zk-rollups" tabindex="-1">Zk-Rollups <a class="header-anchor" href="#zk-rollups" aria-label="Permalink to &quot;Zk-Rollups&quot;">​</a></h2><p>Zk-rollups, aka validity rollups, can also use Celestia as a DA and Blobstream to verify that the data was posted. However, the submission process is different from the above constructions, since there are no fraud proofs, and everything should be verified when submitting the headers.</p><p>So, when posting to the settlement contract, the rollup data in Celestia can be referenced either using a <code>share commitment</code> or a <code>sequence of spans</code>, and a <code>height</code>, similar to the previous constructions.</p><h3 id="zk-rollups-that-uses-a-sequence-of-spans" tabindex="-1">Zk-rollups that uses a sequence of spans <a class="header-anchor" href="#zk-rollups-that-uses-a-sequence-of-spans" aria-label="Permalink to &quot;Zk-rollups that uses a sequence of spans&quot;">​</a></h3><p>So, when submitting the headers to the rollup settlement contract, the settlement contract will need to verify the following:</p><ul><li>Zk-proof of the state transitions, as traditional zk-rollups do.</li><li>Verify that the <code>sequence of spans</code> is <a href="https://github.com/celestiaorg/blobstream-contracts/blob/master/docs/inclusion-proofs.md" target="_blank" rel="noreferrer">valid</a>, i.e., is part of the Celestia block referenced by its height, as described in the previous section.</li><li>Zk-proof of the rollup data to the data root. The verification process of this should accept a commitment as input so that the contract makes sure it&#39;s the correct value that&#39;s being saved. The commitment can be the data root and the sequence of spans. And, when the rollup data is proven inside the circuit to the data root, the used data root is asserted to be the input one. Similarly, the data&#39;s location is asserted to be the same as the input sequence of spans. While these same arguments are the ones used as part of the <code>sequence of spans</code> verification above.</li></ul><p>Once these are valid, the settlement contract can be sure that the state transitions are valid, and the data was posted to Celestia.</p><h3 id="zk-rollups-that-use-share-commitments" tabindex="-1">Zk-rollups that use share commitments <a class="header-anchor" href="#zk-rollups-that-use-share-commitments" aria-label="Permalink to &quot;Zk-rollups that use share commitments&quot;">​</a></h3><p>As explained above, the share commitment proofs generation/verification is still not supported. However, if the team has access to protobuf deserialization inside a zk-circuit, then a similar construction to the <a href="#protobuf-deserialization-contract">protobuf deserialization contract</a> can be done. The zk-proof verifier would take as argument the data root and the share commitment, then inside the circuit, the PFB data will be deserialized, and assert that the deserialized share commitment is the same as the input one. Then, the circuit will prove the inclusion of the PFB to the data root and assert that it&#39;s the same as the input one. If this proof is valid, then the rollup settlement contract can be sure that the rollup data was posted to Celestia and is correctly referenced.</p>',28),r=[i];function l(n,h,c,p,u,d){return t(),o("div",null,r)}const b=e(s,[["render",l]]);export{f as __pageData,b as default};
